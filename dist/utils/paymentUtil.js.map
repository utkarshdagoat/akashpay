{"version":3,"sources":["../../src/utils/paymentUtil.ts"],"sourcesContent":["import { recieveMessage } from \"@/receiverMessages/receiveMessage\";\nimport { burnNoble } from '@/burnNobleContracts/index'\nimport { HttpException } from \"@/exceptions/HttpException\";\nimport { fromBech32, toBech32 } from \"@cosmjs/encoding\";\nimport { DirectSecp256k1HdWallet } from \"@cosmjs/proto-signing\";\nimport { osmosis, FEES } from \"osmojs\";\nimport {\n    lookupRoutesForTrade,\n    getPoolsPricesPairs,\n    calculateAmountWithSlippage\n} from '@cosmology/core';\nconst {\n    swapExactAmountIn,\n} = osmosis.gamm.v1beta1.MessageComposer.withTypeUrl;\nimport axios from 'axios'\nimport { SigningStargateClient, coin } from \"@cosmjs/stargate\";\nexport class PaymentUtil {\n    static async ethToNoble(amount: number) {\n        const [messageHex, attestation] = await burnNoble(\n            process.env.ARBITRUM_TOKEN_MESSENGER_CONTRACT,\n            process.env.ARBITRUM_USDC_ETH_CONTRACT,\n            process.env.ARBITRUM_RPC,\n            process.env.ESCROW_PRIV_KEY,\n            process.env.NOBLE_ADDRESS,\n            amount\n        )\n        if (!process.env.MNEMONIC) throw new HttpException(500, 'Internal Server Error (PaymentUtil.ts)')\n        const txHash = await recieveMessage(\n            process.env.MNEMONIC,\n            messageHex,\n            attestation\n        )\n        return txHash\n    }\n    static deriveCosmosAddress = (\n        chainPrefix: string,\n        address: string\n    ): string => {\n        return toBech32(chainPrefix, fromBech32(address).data);\n    };\n    static  async convertToOsmo(amount: string , reciepentAddress: string) {\n        if (!process.env.MNEMONIC && process.env.NOBLE_RPC && process.env.NOBLE_OSMO_CHANNEL && process.env.GAS) throw new HttpException(500, 'Internal Server Error (PaymentUtil.ts)')\n        const offlineSigner = await DirectSecp256k1HdWallet.fromMnemonic(process.env.MNEMONIC, {\n            prefix: \"noble\"\n        })\n        const signerAddress = (await offlineSigner.getAccounts())[0].address;\n        const osmoReciepentAddress = PaymentUtil.deriveCosmosAddress(\"osmo\", reciepentAddress)\n\n        const signer = await SigningStargateClient.connectWithSigner(\n            process.env.NOBLE_RPC,\n            offlineSigner\n        );\n        signer.sendIbcTokens(\n            signerAddress,\n            osmoReciepentAddress,\n            { denom: \"uusdc\", amount },\n            \"transfer\",\n            process.env.NOBLE_OSMO_CHANNEL,\n            undefined,\n            new Date().getTime() / 1000 + 300,\n            { amount: [], gas: process.env.GAS }\n        ).then((res) => {\n            return res.transactionHash\n        }).catch((err) => {\n            console.error(err)\n            throw new HttpException(500, 'Internal Server Error (PaymentUtil.ts)-[Code-2]')\n        })\n    }\n    public async uosmoTouAkt(amount: string) {\n        //TODO: Cannot implement this on testnet due to no active nodes\n        // The code is written but not tested as testnet cannot be verified\n        // const offlineSigner = await DirectSecp256k1HdWallet.fromMnemonic(process.env.MNEMONIC, {\n        //     prefix: \"noble\"\n        // })\n        // const signerAddress = (await offlineSigner.getAccounts())[0].address;\n        //     const client = await osmosis.ClientFactory.createRPCQueryClient({ rpcEndpoint:process.env.OSMO_RPC });\n        //       const {\n        //       pools,\n        //       prices,\n        //       pairs,\n        //       prettyPools\n        //     } = await getPoolsPricesPairs(client);\n        //     const tokenIn = coin(amount , \"ibc/DE6792CF9E521F6AD6E9A4BDF6225C9571A3B74ACC0A529F92BC5122A39D2E58\")\n        //     const tokenOut = coin(amount ,  \"ibc/AD59D59CFB0E628E73C798415F823AB5B6257C2FE4BF67DBB5D6A677B2686E82\")\n\n        //     const signer = await SigningStargateClient.connectWithSigner(\n        //         process.env.OSMO_RPC,\n        //         offlineSigner\n        //     );\n\n        //     const routes = lookupRoutesForTrade({\n        //       pools,\n        //       trade: {\n        //         ///@ts-ignore\n        //         sell: {\n        //           denom: tokenIn.denom,\n        //           amount: tokenInAmount\n        //         },\n        //         ///@ts-ignore\n        //         buy: {\n        //           denom: tokenOut.denom,\n        //           amount: tokenOutAmount\n        //         },\n        //         beliefValue: \"100000\",\n        //       },\n        //       pairs\n        //     }).map((tradeRoute) => {\n        //       const {\n        //         poolId,\n        //         tokenOutDenom\n        //       } = tradeRoute;\n        //       return {\n        //         poolId,\n        //         tokenOutDenom\n        //       };\n        //     });\n\n\n        //     const tokenOutMinAmount = calculateAmountWithSlippage(\n        //       \"100000\",\n        //       \"1\"\n        //     );\n\n        //     const fee = FEES.osmosis.swapExactAmountIn('low'); // low, medium, high\n        //     ///@ts-ignore\n        //     const msg = swapExactAmountIn({\n        //       sender: signerAddress, // osmo address\n        //       ///@ts-ignore\n        //       routes, // TradeRoute \n        //       tokenIn, // Coin\n        //       tokenOutMinAmount // number as string with no decimals\n        //     });\n        //     const result = await signer.signAndBroadcast(\n        //           signerAddress,\n        //           [msg],\n        //           fee,\n        //           'swap tokens'\n        //         );\n        // }\n    }\n}"],"names":["PaymentUtil","swapExactAmountIn","osmosis","gamm","v1beta1","MessageComposer","withTypeUrl","ethToNoble","amount","messageHex","attestation","burnNoble","process","env","ARBITRUM_TOKEN_MESSENGER_CONTRACT","ARBITRUM_USDC_ETH_CONTRACT","ARBITRUM_RPC","ESCROW_PRIV_KEY","NOBLE_ADDRESS","MNEMONIC","HttpException","txHash","recieveMessage","convertToOsmo","reciepentAddress","NOBLE_RPC","NOBLE_OSMO_CHANNEL","GAS","offlineSigner","DirectSecp256k1HdWallet","fromMnemonic","prefix","signerAddress","getAccounts","address","osmoReciepentAddress","deriveCosmosAddress","signer","SigningStargateClient","connectWithSigner","sendIbcTokens","denom","undefined","Date","getTime","gas","then","res","transactionHash","catch","err","console","error","uosmoTouAkt","chainPrefix","toBech32","fromBech32","data"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BAgBaA;;;eAAAA;;;gCAhBkB;uBACL;+BACI;0BACO;8BACG;wBACV;0BAUc;;;;;;;;;;;;;;AAJ5C,MAAM,EACFC,iBAAiB,EACpB,GAAGC,eAAO,CAACC,IAAI,CAACC,OAAO,CAACC,eAAe,CAACC,WAAW;AAG7C,IAAA,AAAMN,cAAN,MAAMA;IACT,aAAaO,WAAWC,MAAc,EAAE;QACpC,MAAM,CAACC,YAAYC,YAAY,GAAG,MAAMC,IAAAA,gBAAS,EAC7CC,QAAQC,GAAG,CAACC,iCAAiC,EAC7CF,QAAQC,GAAG,CAACE,0BAA0B,EACtCH,QAAQC,GAAG,CAACG,YAAY,EACxBJ,QAAQC,GAAG,CAACI,eAAe,EAC3BL,QAAQC,GAAG,CAACK,aAAa,EACzBV;QAEJ,IAAI,CAACI,QAAQC,GAAG,CAACM,QAAQ,EAAE,MAAM,IAAIC,4BAAa,CAAC,KAAK;QACxD,MAAMC,SAAS,MAAMC,IAAAA,8BAAc,EAC/BV,QAAQC,GAAG,CAACM,QAAQ,EACpBV,YACAC;QAEJ,OAAOW;IACX;IAOA,aAAcE,cAAcf,MAAc,EAAGgB,gBAAwB,EAAE;QACnE,IAAI,CAACZ,QAAQC,GAAG,CAACM,QAAQ,IAAIP,QAAQC,GAAG,CAACY,SAAS,IAAIb,QAAQC,GAAG,CAACa,kBAAkB,IAAId,QAAQC,GAAG,CAACc,GAAG,EAAE,MAAM,IAAIP,4BAAa,CAAC,KAAK;QACtI,MAAMQ,gBAAgB,MAAMC,qCAAuB,CAACC,YAAY,CAAClB,QAAQC,GAAG,CAACM,QAAQ,EAAE;YACnFY,QAAQ;QACZ;QACA,MAAMC,gBAAgB,AAAC,CAAA,MAAMJ,cAAcK,WAAW,EAAC,CAAE,CAAC,EAAE,CAACC,OAAO;QACpE,MAAMC,uBAAuBnC,YAAYoC,mBAAmB,CAAC,QAAQZ;QAErE,MAAMa,SAAS,MAAMC,+BAAqB,CAACC,iBAAiB,CACxD3B,QAAQC,GAAG,CAACY,SAAS,EACrBG;QAEJS,OAAOG,aAAa,CAChBR,eACAG,sBACA;YAAEM,OAAO;YAASjC;QAAO,GACzB,YACAI,QAAQC,GAAG,CAACa,kBAAkB,EAC9BgB,WACA,IAAIC,OAAOC,OAAO,KAAK,OAAO,KAC9B;YAAEpC,QAAQ,EAAE;YAAEqC,KAAKjC,QAAQC,GAAG,CAACc,GAAG;QAAC,GACrCmB,IAAI,CAAC,CAACC;YACJ,OAAOA,IAAIC,eAAe;QAC9B,GAAGC,KAAK,CAAC,CAACC;YACNC,QAAQC,KAAK,CAACF;YACd,MAAM,IAAI9B,4BAAa,CAAC,KAAK;QACjC;IACJ;IACA,MAAaiC,YAAY7C,MAAc,EAAE,CAuEzC;AACJ;AA1GI,iBAlBSR,aAkBFoC,uBAAsB,CACzBkB,aACApB;IAEA,OAAOqB,IAAAA,kBAAQ,EAACD,aAAaE,IAAAA,oBAAU,EAACtB,SAASuB,IAAI;AACzD"}