{"version":3,"sources":["../../src/middlewares/signverify.middleware.ts"],"sourcesContent":["import { HttpException } from \"@/exceptions/HttpException\";\nimport { HmacUtil } from \"@/utils/hmacSignUtil\";\nimport { PrismaClient } from \"@prisma/client\";\nimport { Request, Response, NextFunction } from \"express\";\n\n\nfunction getAppIdAndSignFromHeader(req: Request): [string, string] {\n    const authHeader = req.header('Authorization')\n    if (!authHeader) {\n        throw new HttpException(400, 'Authorization header is missing')\n    }\n    const tokens = authHeader.split(' ')[1];\n    const [appId, sign] = tokens.split(':')\n    return [appId, sign]\n}\nfunction getNonceFromHeader(req: Request): string {\n    const nonce = req.header('X-TXC-NONCE');\n    if(!nonce) {\n        throw new HttpException(400, 'Nonce header is missing')\n    }\n    return nonce\n}\nfunction getTimeStampFromHeader(req: Request): string {\n    const timestamp = req.header('X-TXC-TIMESTAMP');\n    if(!timestamp) {\n        throw new HttpException(400, 'Timestamp header is missing')\n    }\n    return timestamp\n}\n\n\n\nexport const SignVerifyMiddleware = async (req: Request, res: Response, next: NextFunction) => {\n    const applications = new PrismaClient().application;\n    try {\n        const [appId, sign] = getAppIdAndSignFromHeader(req)\n        const application = await applications.findUnique({ where: { appId } })\n        if (!application) {\n            next(new HttpException(400, 'Application not found'))\n        }\n        const { clientSecret } = application\n        const nonce = getNonceFromHeader(req)\n        const timestamp = getTimeStampFromHeader(req)\n        const requestURI = req.protocol + '://' + req.get('host') + req.originalUrl;\n        const stringToSign = HmacUtil.getStringToSign(req.body,nonce,timestamp,req.method,requestURI)\n        const VerifiedSign = HmacUtil.hmac256(clientSecret, stringToSign)\n        if(sign == VerifiedSign) {\n            next()\n        }else{\n            next(new HttpException(401, 'The Signature is invalid'))\n        }\n    } catch (error) {\n        next(error)\n    }\n\n}"],"names":["SignVerifyMiddleware","getAppIdAndSignFromHeader","req","authHeader","header","HttpException","tokens","split","appId","sign","getNonceFromHeader","nonce","getTimeStampFromHeader","timestamp","res","next","applications","PrismaClient","application","findUnique","where","clientSecret","requestURI","protocol","get","originalUrl","stringToSign","HmacUtil","getStringToSign","body","method","VerifiedSign","hmac256","error"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BAgCaA;;;eAAAA;;;+BAhCiB;8BACL;wBACI;AAI7B,SAASC,0BAA0BC,GAAY;IAC3C,MAAMC,aAAaD,IAAIE,MAAM,CAAC;IAC9B,IAAI,CAACD,YAAY;QACb,MAAM,IAAIE,4BAAa,CAAC,KAAK;IACjC;IACA,MAAMC,SAASH,WAAWI,KAAK,CAAC,IAAI,CAAC,EAAE;IACvC,MAAM,CAACC,OAAOC,KAAK,GAAGH,OAAOC,KAAK,CAAC;IACnC,OAAO;QAACC;QAAOC;KAAK;AACxB;AACA,SAASC,mBAAmBR,GAAY;IACpC,MAAMS,QAAQT,IAAIE,MAAM,CAAC;IACzB,IAAG,CAACO,OAAO;QACP,MAAM,IAAIN,4BAAa,CAAC,KAAK;IACjC;IACA,OAAOM;AACX;AACA,SAASC,uBAAuBV,GAAY;IACxC,MAAMW,YAAYX,IAAIE,MAAM,CAAC;IAC7B,IAAG,CAACS,WAAW;QACX,MAAM,IAAIR,4BAAa,CAAC,KAAK;IACjC;IACA,OAAOQ;AACX;AAIO,MAAMb,uBAAuB,OAAOE,KAAcY,KAAeC;IACpE,MAAMC,eAAe,IAAIC,oBAAY,GAAGC,WAAW;IACnD,IAAI;QACA,MAAM,CAACV,OAAOC,KAAK,GAAGR,0BAA0BC;QAChD,MAAMgB,cAAc,MAAMF,aAAaG,UAAU,CAAC;YAAEC,OAAO;gBAAEZ;YAAM;QAAE;QACrE,IAAI,CAACU,aAAa;YACdH,KAAK,IAAIV,4BAAa,CAAC,KAAK;QAChC;QACA,MAAM,EAAEgB,YAAY,EAAE,GAAGH;QACzB,MAAMP,QAAQD,mBAAmBR;QACjC,MAAMW,YAAYD,uBAAuBV;QACzC,MAAMoB,aAAapB,IAAIqB,QAAQ,GAAG,QAAQrB,IAAIsB,GAAG,CAAC,UAAUtB,IAAIuB,WAAW;QAC3E,MAAMC,eAAeC,sBAAQ,CAACC,eAAe,CAAC1B,IAAI2B,IAAI,EAAClB,OAAME,WAAUX,IAAI4B,MAAM,EAACR;QAClF,MAAMS,eAAeJ,sBAAQ,CAACK,OAAO,CAACX,cAAcK;QACpD,IAAGjB,QAAQsB,cAAc;YACrBhB;QACJ,OAAK;YACDA,KAAK,IAAIV,4BAAa,CAAC,KAAK;QAChC;IACJ,EAAE,OAAO4B,OAAO;QACZlB,KAAKkB;IACT;AAEJ"}